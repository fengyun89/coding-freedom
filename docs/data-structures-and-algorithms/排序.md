# 排序

## 冒泡排序

像泡泡一样往上冒

```js
function bubbleSort(arr) {
  // 需要多少次冒泡
  for (let i = 0; i < arr.length - 1; i++) {
    // 每次冒泡需要比较多少次
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }
}
```

## 选择排序

未排序的部分中，`选择`最小值，放到最前面

```js
function selectSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i;
    // 从未排序的部分中找到最小值的索引
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    
    // 将找到的最小元素和第一个元素交换
    const temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
}
```

## 插入排序

`插入`到已排序的部分中

```js
function insertSort(arr) {
  // 从未排序的部分中选择第一个
  for (let i = 1; i < arr.length; i++) {
    // 和前面已排序的部分依次比较
    for (let j = 0; j < i; j++) {
      if (arr[i] < arr[j]) {
        const temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
      }
    }
  }
}
```

## 希尔排序

相比于简单的插入排序，希尔排序可以更快地将大的元素移动到正确的位置，交换操作会更少

```js
function shellSort(arr) {
  // 步长
  let gap = Math.floor(arr.length / 2);

  while (gap > 0) {
    // 按照步长给元素分组
    for (let i = 0; i < gap; i++) {
      // 每组进行插入排序
      for (let j = i + gap; j < arr.length; j += gap) {
        for (let m = i; m < j; m += gap) {
          if (arr[j] < arr[m]) {
            const temp = arr[m];
            arr[m] = arr[j];
            arr[j] = temp;
          }
        }
      }
    }

    // 减少步长
    gap = Math.floor(gap / 2);
  }
}
```

## 归并排序

```js
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  const sortedLeft = mergeSort(left);
  const sortedRight = mergeSort(right);

  return merge(sortedLeft, sortedRight);
}

// 合并两个有序数组
function merge(left, right) {
  const merged = [];
  let leftIndex = 0;
  let rightIndex = 0;

  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      merged.push(left[leftIndex]);
      leftIndex++;
    } else {
      merged.push(right[rightIndex]);
      rightIndex++;
    }
  }

  while (leftIndex < left.length) {
    merged.push(left[leftIndex]);
    leftIndex++;
  }

  while (rightIndex < right.length) {
    merged.push(right[rightIndex]);
    rightIndex++;
  }

  return merged;
}
```

## 快速排序

## 堆排序

## 计数排序

## 桶排序

## 基数排序

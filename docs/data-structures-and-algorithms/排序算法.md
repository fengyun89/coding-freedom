# 排序算法

| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| -------- | -------------- | -------- | -------- | ---------- | -------- | ------ |
| 冒泡排序 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | In-place | 稳定   |
| 选择排序 | O(n^2)         | O(n^2)   | O(n^2)   | O(1)       | In-place | 不稳定 |
| 插入排序 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | In-place | 稳定   |
| 希尔排序 | O(nlogn)       | O(nlog^2n) | O(nlog^2n) | O(1)       | In-place | 不稳定 |
| 归并排序 | O(nlogn)       | O(nlogn) | O(nlogn) | O(n)       | Out-place | 稳定   |
| 快速排序 | O(nlogn)       | O(nlogn) | O(n^2)   | O(logn)    | In-place | 不稳定 |
| 堆排序   | O(nlogn)       | O(nlogn) | O(nlogn) | O(1)       | In-place | 不稳定 |
| 计数排序 | O(n+k)         | O(n+k)   | O(n+k)   | O(k)       | Out-place | 稳定   |
| 基数排序 | O(n*k)         | O(n*k)   | O(n*k)   | O(n+k)     | Out-place | 稳定   |
| 桶排序   | O(n+k)         | O(n+k)   | O(n^2)   | O(n+k)     | Out-place | 稳定   |

## 冒泡排序

像泡泡一样往上冒

```js
function bubbleSort(arr) {
  // 需要多少次冒泡
  for (let i = 0; i < arr.length - 1; i++) {
    // 每次冒泡需要比较多少次
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }
}
```

## 选择排序

未排序的部分中，`选择`最小值，放到最前面

```js
function selectSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i;
    // 从未排序的部分中找到最小值的索引
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    
    // 将找到的最小元素和第一个元素交换
    const temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
}
```

## 插入排序

`插入`到已排序的部分中

```js
function insertSort(arr) {
  // 从未排序的部分中选择第一个
  for (let i = 1; i < arr.length; i++) {
    // 和前面已排序的部分依次比较
    for (let j = 0; j < i; j++) {
      if (arr[i] < arr[j]) {
        const temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
      }
    }
  }
}
```

## 希尔排序

相比于简单的插入排序，希尔排序可以更快地将大的元素移动到正确的位置，交换操作会更少

```js
function shellSort(arr) {
  // 步长
  let gap = Math.floor(arr.length / 2);

  while (gap > 0) {
    // 按照步长给元素分组
    for (let i = 0; i < gap; i++) {
      // 每组进行插入排序
      for (let j = i + gap; j < arr.length; j += gap) {
        for (let m = i; m < j; m += gap) {
          if (arr[j] < arr[m]) {
            const temp = arr[m];
            arr[m] = arr[j];
            arr[j] = temp;
          }
        }
      }
    }

    // 减少步长
    gap = Math.floor(gap / 2);
  }
}
```

## 归并排序

```js
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  const sortedLeft = mergeSort(left);
  const sortedRight = mergeSort(right);

  return merge(sortedLeft, sortedRight);
}

// 合并两个有序数组
function merge(left, right) {
  const merged = [];
  let leftIndex = 0;
  let rightIndex = 0;

  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      merged.push(left[leftIndex]);
      leftIndex++;
    } else {
      merged.push(right[rightIndex]);
      rightIndex++;
    }
  }

  while (leftIndex < left.length) {
    merged.push(left[leftIndex]);
    leftIndex++;
  }

  while (rightIndex < right.length) {
    merged.push(right[rightIndex]);
    rightIndex++;
  }

  return merged;
}
```

## 快速排序

```js
function quickSort(arr) {
  if (arr.length === 0 || arr.length === 1) return arr;
  let low = 0;
  let high = arr.length - 1;
  let pivot = arr[0];
  let moveHigh = true;
  while (low !== high) {
    if (moveHigh) {
      if (arr[high] >= pivot) {
        high--;
      } else {
        arr[low] = arr[high];
        low++;
        moveHigh = false;
      }
    } else {
      if (arr[low] <= pivot) {
        low++;
      } else {
        arr[high] = arr[low];
        high--;
        moveHigh = true;
      }
    }
  }
  arr[low] = pivot;

  return [
    ...quickSort(arr.slice(0, low)),
    pivot,
    ...quickSort(arr.slice(low + 1)),
  ];
}
```

## 堆排序

## 计数排序

通过计数而不是比较来排序

```js
function countingSort(arr) {
  if (arr.length < 2) return;

  // 找到最大值
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }

  const countingArr = Array(max + 1).fill(0);
  for (let i = 0; i < arr.length; i++) {
    countingArr[arr[i]] += 1;
  }

  let sortedIndex = 0;
  for (let i = 0; i < countingArr.length; i++) {
    while (countingArr[i] > 0) {
      arr[sortedIndex] = i;
      sortedIndex++;
      countingArr[i]--;
    }
  }
}
```

## 基数排序

```js
function radixSort(arr) {
  // 最大值
  const max = Math.max(...arr);
  // 最大值的位数
  const maxDigits = Math.floor(Math.log10(max) + 1);

  for (let i = 0; i < maxDigits; i++) {
    // 10个桶
    const buckets = Array.from({ length: 10 }, () => []);

    for (let j = 0; j < arr.length; j++) {
      const digit = Math.floor(arr[j] / Math.pow(10, i)) % 10;
      buckets[digit].push(arr[j]);
    }

    arr = buckets.flat();
  }
  return arr;
}
```

## 桶排序

```js
function bucketSort(arr, bucketSize = 3) {
  // 最大值和最小值
  let min = arr[0];
  let max = arr[0];
  for (let i = 0; i < arr.length; i++) {
    if (min > arr[i]) min = arr[i];
    if (max < arr[i]) max = arr[i];
  }

  // 桶的初始化
  const bucketCount = Math.floor((max - min) / bucketSize) + 1;
  const buckets = [];
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [];
  }

  // 分配到各个桶中
  for (let i = 0; i < arr.length; i++) {
    const index = Math.floor((arr[i] - min) / bucketSize);
    buckets[index].push(arr[i]);
  }

  // 对每个桶进行排序
  arr.length = 0;
  for (let i = 0; i < buckets.length; i++) {
    buckets[i].sort((a, b) => a - b);
    for (let j = 0; j < buckets[i].length; j++) {
      arr.push(buckets[i][j]);
    }
  }
}
```

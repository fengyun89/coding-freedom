# 栈(Stack)

栈是一种操作受限的线性表，只允许在一端插入和删除数据元素，又称为后进先出(Last In First Out, LIFO)的线性表。

## 栈的相关概念

允许插入和删除的一端叫`栈顶`，另一端叫`栈底`。

栈的插入操作，叫`入栈`；栈的删除操作，叫`出栈`。

栈中的元素数量达到了栈的最大容量时，栈处于`栈满`状态。

栈中没有任何元素时，栈处于`栈空`状态。

## 栈的抽象数据类型

```
ADT Stack {
    数据对象：
        D = { ei | ei ∈ ElementSet, i = 1, 2, ..., n, n >= 0 }
    数据关系：
        R = { <ei-1, ei> | ei-1, ei ∈ D, i = 2, 3, ..., n }
    基本操作：
        push(e) 入栈
        pop() 出栈
        peek() 查看栈顶元素
        isEmpty() 判断栈是否为空
        clear() 清空栈
        size() 获取栈中元素的个数
        print() 打印栈中的元素
}
```

## 栈的顺序存储实现 —— 顺序栈(Sequential Stack)

```js
class SequentialStack {
  #data = [];

  // 入栈
  push(element) {
    this.#data.push(element);
  }

  // 出栈
  pop() {
    return this.#data.pop();
  }

  // 查看栈顶元素
  peek() {
    return this.#data[this.#data.length - 1];
  }

  // 判断栈是否为空
  isEmpty() {
    return this.size() === 0;
  }

  // 清空栈
  clear() {
    this.#data = [];
  }

  // 获取栈中元素的个数
  size() {
    return this.#data.length;
  }

  // 打印栈中的元素
  print() {
    console.log(this.#data.toString());
  }
}
```

## 栈的链式存储实现 —— 链栈(Linked Stack)

```js
class LinkedStack {
  #data = {};
  #count = 0;

  // 入栈
  push(element) {
    this.#data[this.#count++] = element;
  }

  // 出栈
  pop() {
    if (this.isEmpty()) {
      return undefined;
    }
    delete this.#data[--this.#count];
    return this.#data[this.#count];
  }

  // 查看栈顶元素
  peek() {
    return this.#data[this.#count - 1];
  }

  // 判断栈是否为空
  isEmpty() {
    return this.#count === 0;
  }

  // 清空栈
  clear() {
    this.#data = {};
    this.#count = 0;
  }

  // 获取栈中元素的个数
  size() {
    return this.#count;
  }

  // 打印栈中的元素
  print() {
    console.log(Object.values(this.#data).toString());
  }
}
```

## 栈的应用

### 括号匹配

```js
const isBracketMatch = (str) => {
  const stack = new Stack();
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === '(') {
      stack.push(char);
    } else if (char === ')') {
      if (stack.isEmpty()) {
        return false;
      }
      stack.pop();
    }
  }
  return stack.isEmpty();
}
```

### 求斐波那契数

```js title=用递归实现
const fibonacci = (n) => {
  if (n <= 2) return 1;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

```js title=用栈实现
const fibonacci = (n) => {
  if (n <= 2) return 1;
  const stack = new Stack();
  stack.push(1);
  stack.push(1);
  let i = 2;
  while (i < n) {
    const first = stack.pop();
    const second = stack.pop();
    stack.push(first);
    stack.push(first + second);
    i++;
  }
  return stack.pop();
}
```

### 十进制转二进制

```js
const decimalToBinary = (decNumber) => {
  const stack = new Stack();
  while (decNumber > 0) {
    stack.push(decNumber % 2);
    decNumber = Math.floor(decNumber / 2);
  }
  let binaryString = '';
  while (!stack.isEmpty()) {
    binaryString += stack.pop();
  }
  return binaryString;
}
```

```js title=十进制转任意进制
const baseConverter = (decNumber, base) => {
  const stack = new Stack();
  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  while (decNumber > 0) {
    stack.push(decNumber % base);
    decNumber = Math.floor(decNumber / base);
  }
  let binaryString = '';
  while (!stack.isEmpty()) {
    binaryString += digits[stack.pop()];
  }
  return binaryString;
}
```

### 表达式求值

```js title=中缀表达式转后缀表达式
const priority = (peek) => {
  switch (peek) {
    case '+':
    case '-':
      return 1;
    case '*':
    case '/':
      return 2;
  }
}

const infixToPostfix = (str) => {
  const stack = new Stack();
  const operators = '+-*/()';
  const tokens = str.split('');
  let postfix = '';
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token === ' ') continue;
    if (operators.includes(token)) {
      if (token === '(') {
        stack.push(token);
      } else if (token === ')') {
        let top = stack.pop();
        while (top !== '(') {
          postfix += top + ' ';
          top = stack.pop();
        }
      } else {
        while (!stack.isEmpty() && priority(stack.peek()) >= priority(token)) {
          postfix += stack.pop() + ' ';
        }
        stack.push(token);
      }
    } else {
      postfix += token + ' ';
    }
  }
  while (!stack.isEmpty()) {
    postfix += stack.pop() + ' ';
  }
  return postfix;
}
```

```js title=后缀表达式求值
const calc = (str) => {
  const stack = new Stack();
  const operators = '+-*/';
  const tokens = str.split(' ');
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (operators.includes(token)) {
      const second = stack.pop();
      const first = stack.pop();
      switch (token) {
        case '+':
          stack.push(first + second);
          break;
        case '-':
          stack.push(first - second);
          break;
        case '*':
          stack.push(first * second);
          break;
        case '/':
          stack.push(first / second);
          break;
      }
    } else {
      stack.push(Number(token));
    }
  }
  return stack.pop();
}
```
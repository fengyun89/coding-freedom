# 栈(Stack)

栈是一种操作受限的线性表，只允许在一端插入和删除数据元素，又称为后进先出(Last In First Out, LIFO)的线性表。

## 栈的相关概念

允许插入和删除的一端叫`栈顶`，另一端叫`栈底`。

栈的插入操作，叫`入栈`；栈的删除操作，叫`出栈`。

栈中的元素数量达到了栈的最大容量时，栈处于`栈满`状态，处于栈满状态的栈，称为`满栈`；栈中没有任何元素时，栈处于`栈空`状态，处于栈空状态的栈，称为`空栈`。

## 栈的抽象数据类型

```
ADT Stack {
    数据对象：
        D = { ai | ai ∈ ElementSet, i = 1, 2, ..., n, n >= 0 }
    数据关系：
        R1 = { <ai-1, ai> | ai-1, ai ∈ D, i = 2, 3, ..., n }
    基本操作：
        push(e) 入栈
        pop() 出栈
        peek() 查看栈顶元素
        isEmpty() 判断栈是否为空
        clear() 清空栈
        size() 获取栈中元素的个数
        print() 打印栈中的元素
}
```

## 栈的顺序存储实现 —— 顺序栈

```js
class SequentialStack {
  #data = [];

  // 入栈
  push(element) {
    this.#data.push(element);
  }

  // 出栈
  pop() {
    return this.#data.pop();
  }

  // 查看栈顶元素
  peek() {
    return this.#data[this.#data.length - 1];
  }

  // 判断栈是否为空
  isEmpty() {
    return this.size() === 0;
  }

  // 清空栈
  clear() {
    this.#data = [];
  }

  // 获取栈中元素的个数
  size() {
    return this.#data.length;
  }

  // 打印栈中的元素
  print() {
    console.log(this.#data.toString());
  }
}
```

## 栈的链式存储实现 —— 链栈

```js
class LinkedStack {
  #data = {};
  #count = 0;

  // 入栈
  push(element) {
    this.#data[this.#count++] = element;
  }

  // 出栈
  pop() {
    if (this.isEmpty()) {
      return undefined;
    }
    delete this.#data[--this.#count];
    return this.#data[this.#count];
  }

  // 查看栈顶元素
  peek() {
    return this.#data[this.#count - 1];
  }

  // 判断栈是否为空
  isEmpty() {
    return this.#count === 0;
  }

  // 清空栈
  clear() {
    this.#data = {};
    this.#count = 0;
  }

  // 获取栈中元素的个数
  size() {
    return this.#count;
  }

  // 打印栈中的元素
  print() {
    console.log(Object.values(this.#data).toString());
  }
}
```

## 栈的应用

### 括号匹配

```js
const isBracketMatch = (str) => {
  const stack = new Stack();
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === '(') {
      stack.push(char);
    } else if (char === ')') {
      if (stack.isEmpty()) {
        return false;
      }
      stack.pop();
    }
  }
  return stack.isEmpty();
}
```

### 求斐波那契数

```js title=用递归实现
const fibonacci = (n) => {
  if (n <= 2) return 1;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

```js title=用栈实现
const fibonacci = (n) => {
  if (n <= 2) return 1;
  const stack = new Stack();
  stack.push(1);
  stack.push(1);
  let i = 2;
  while (i < n) {
    const first = stack.pop();
    const second = stack.pop();
    stack.push(first);
    stack.push(first + second);
    i++;
  }
  return stack.pop();
}
```

### 十进制转二进制

```js
const decimalToBinary = (decNumber) => {
  const stack = new Stack();
  while (decNumber > 0) {
    stack.push(decNumber % 2);
    decNumber = Math.floor(decNumber / 2);
  }
  let binaryString = '';
  while (!stack.isEmpty()) {
    binaryString += stack.pop();
  }
  return binaryString;
}
```

```js title=十进制转任意进制
const baseConverter = (decNumber, base) => {
  const stack = new Stack();
  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  while (decNumber > 0) {
    stack.push(decNumber % base);
    decNumber = Math.floor(decNumber / base);
  }
  let binaryString = '';
  while (!stack.isEmpty()) {
    binaryString += digits[stack.pop()];
  }
  return binaryString;
}
```

### 表达式求值

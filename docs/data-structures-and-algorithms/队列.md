# 队列(Queue)

队列和栈相似，也是一种操作受限的线性表，只允许在一端进行插入，而在另一端进行删除，又称为先进先出(First In First Out, FIFO)的线性表。

## 队列的相关概念

允许插入的一端叫`队尾`，允许删除的一端叫`队头`。

队列的插入操作，叫`入队`；队列的删除操作，叫`出队`。

队列中的元素数量达到了队列的最大容量时，队列处于`队满`状态。

队列中没有任何元素时，队列处于`队空`状态。

## 队列的抽象数据类型

```
ADT Queue {
    数据对象：
        D = { ai | ai ∈ ElementSet, i = 1, 2, ..., n, n >= 0 }
    数据关系：
        R1 = { <ai-1, ai> | ai-1, ai ∈ D, i = 2, 3, ..., n }
    基本操作：
        enqueue(e) 入队
        dequeue() 出队
        peek() 查看队头元素
        isEmpty() 判断队列是否为空
        clear() 清空队列
        size() 获取队列中元素的个数
        print() 打印队列中的元素
}
```

## 队列的顺序存储实现 —— 顺序队列(Sequential Queue)

```js
export default class SequentialQueue {
  #data = [];

  // 入队
  enqueue(element) {
    this.#data.push(element);
  }

  // 出队
  dequeue() {
    return this.#data.pop();
  }

  // 查看队头元素
  peek() {
    return this.#data[0];
  }

  // 判断队列是否为空
  isEmpty() {
    return this.#data.length === 0;
  }

  // 清空队列
  clear() {
    this.#data = [];
  }

  // 获取队列中元素的个数
  size() {
    return this.#data.length;
  }

  // 打印队列中的元素
  print() {
    console.log(this.#data.toString());
  }
}
```

## 队列的链式存储实现 —— 链式队列(Linked Queue)

```js
export default class LinkedQueue {
  #data = {};
  #head = 0;
  #tail = 0;

  // 入队
  enqueue(element) {
    this.#data[this.#tail] = element;
    this.#tail++;
  }

  // 出队
  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    const result = this.#data[this.#head];
    delete this.#data[this.#head];
    this.#head++;
    return result;
  }

  // 查看队头元素
  peek() {
    return this.#data[this.#head];
  }

  // 判断队列是否为空
  isEmpty() {
    return this.size() === 0;
  }

  // 清空队列
  clear() {
    this.#data = {};
    this.#head = 0;
    this.#tail = 0;
  }

  // 获取队列中元素的个数
  size() {
    return this.#tail - this.#head;
  }

  // 打印队列中的元素
  print() {
    let result = '';
    for (let i = this.#head; i < this.#tail; i++) {
      result += `,${this.#data[i]}`;
    }
    console.log(result);
  }
}
```

## 双端队列(Deque)

Double-Ended Queue 缩写为 Deque，是一种允许在队列的两端进行插入和删除操作的特殊队列。

```js
class Deque {
  #data = {};
  #head = null;
  #tail = null;

  // 从队尾入队
  enqueueTail(element) {
    if (this.isEmpty()) {
      this.#head = 1;
      this.#tail = 1;
    } else {
      this.#tail++;
    }
    this.#data[this.#tail] = element;
  }

  // 从队头入队
  enqueueHead(element) {
    if (this.isEmpty()) {
      this.#head = 1;
      this.#tail = 1;
    } else {
      this.#head--;
    }
    this.#data[this.#head] = element;
  }

  // 从队尾出队
  dequeueTail() {
    if (this.isEmpty()) return null;
    const result = this.#data[this.#tail];
    delete this.#data[this.#tail];
    if (this.#head === this.#tail) {
      this.#head = null;
      this.#tail = null;
    } else {
      this.#tail--;
    }
    return result;
  }

  // 从队头出队
  dequeueHead() {
    if (this.isEmpty()) return null;
    const result = this.#data[this.#head];
    delete this.#data[this.#head];
    if (this.#head === this.#tail) {
      this.#head = null;
      this.#tail = null;
    } else {
      this.#head++;
    }
    return result;
  }

  // 查看队头元素
  peek() {
    if (this.isEmpty()) return null;
    return this.#data[this.#head];
  }

  // 查看队尾元素
  peekTail() {
    if (this.isEmpty()) return null;
    return this.#data[this.#tail];
  }

  // 判断队列是否为空
  isEmpty() {
    return this.size() === 0;
  }

  // 清空队列
  clear() {
    this.#data = {};
    this.#head = null;
    this.#tail = null;
  }

  // 获取队列中元素的个数
  size() {
    if (this.#head === null) return 0;
    return this.#tail - this.#head + 1;
  }

  // 打印队列中的元素
  print() {
    let result = '';
    if (this.isEmpty()) {
      console.log(result);
      return;
    }
    result += this.#data[this.#head];
    for (let i = this.#head + 1; i <= this.#tail; i++) {
      result += `,${this.#data[i]}`;
    }
    console.log(result);
  }
}
```

## 队列的应用

### 击鼓传花

```js
import Queue from './SequentialQueue.js'

const queue = new Queue()
queue.enqueue('John')
queue.enqueue('Jack')
queue.enqueue('Camila')
queue.enqueue('Carl')
queue.enqueue('Tom')
queue.enqueue('Mike')

const number = 8

while (queue.size() > 1) {
  queue.print()
  console.log(`击鼓传花游戏开始，花在${queue.peek()}手上`)
  for (let i = 0; i < number; i++) {
    queue.enqueue(queue.dequeue())
  }
  console.log(`传递${number}次后，花在${queue.peek()}手上`)
  console.log(`${queue.dequeue()}被淘汰`)
}

console.log(`胜利者是${queue.dequeue()}`)
```

### 回文检查

```js
import Queue from './Deque.js'

const str = 'abcba'

const isPalindrome = (str) => {
    const queue = new Queue()
    for (let i = 0; i < str.length; i++) {
        queue.enqueueTail(str[i])
    }
    while (queue.size() > 1) {
        if (queue.dequeueHead() !== queue.dequeueTail()) {
            return false
        }
    }
    return true
}

console.log(isPalindrome(str))
```

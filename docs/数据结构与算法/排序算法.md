# 排序算法

| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| -------- | -------------- | -------- | -------- | ---------- | -------- | ------ |
| 冒泡排序 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | In-place | 稳定   |
| 选择排序 | O(n^2)         | O(n^2)   | O(n^2)   | O(1)       | In-place | 不稳定 |
| 插入排序 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | In-place | 稳定   |
| 希尔排序 | O(nlogn)       | O(nlog^2n) | O(nlog^2n) | O(1)       | In-place | 不稳定 |
| 归并排序 | O(nlogn)       | O(nlogn) | O(nlogn) | O(n)       | Out-place | 稳定   |
| 快速排序 | O(nlogn)       | O(nlogn) | O(n^2)   | O(logn)    | In-place | 不稳定 |
| 堆排序   | O(nlogn)       | O(nlogn) | O(nlogn) | O(1)       | In-place | 不稳定 |
| 计数排序 | O(n+k)         | O(n+k)   | O(n+k)   | O(k)       | Out-place | 稳定   |
| 基数排序 | O(n*k)         | O(n*k)   | O(n*k)   | O(n+k)     | Out-place | 稳定   |
| 桶排序   | O(n+k)         | O(n+k)   | O(n^2)   | O(n+k)     | Out-place | 稳定   |

## 冒泡排序

冒泡排序的思想是通过相邻元素之间的比较和交换来逐步将最大（或最小）的元素移动到正确的位置。

冒泡排序的步骤

1. 从第一个元素开始，依次比较相邻的两个元素，如果前一个元素比后一个元素大，则交换它们的位置，否则保持不变。
2. 继续对每一对相邻的元素进行比较和交换，直到最后一个元素。最大的元素，像气泡一样浮到最后一个位置。
3. 对剩下未排序的元素重复执行第1-2步，直到完成所有元素的排序。

```js
function bubbleSort(arr) {
  const length = arr.length;

  // 控制需要多少趟排序
  for (let i = 0; i < length - 1; i++) {
    // 控制每一趟排序需要比较多少次
    for (let j = 0; j < length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
      }
    }
  }
}
```

## 选择排序

选择排序的思想是在未排序部分中选择最小的元素，并将其与未排序部分的第一个元素交换位置。

```js
function selectionSort(arr) {
  const length = arr.length;

  for (let i = 0; i < length - 1; i++) {
    // 未排序的部分中最小值的索引
    let minIndex = i;
    for (let j = i; j < length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    // 交换位置
    [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];
  }
}
```

## 插入排序

插入排序思想是将数组分为已排序部分和未排序部分，依次将未排序部分的元素插入到已排序部分的正确位置。

```js
function insertionSort(arr) {
  const length = arr.length;

  // 从未排序的部分中取出第一个元素
  for (let i = 1; i < length; i++) {
    // 插入到已排序的部分
    for (let j = 0; j < i; j++) {
      if (arr[i] < arr[j]) {
        const [item] = arr.splice(i, 1);
        arr.splice(j, 0, item);
      }
    }
  }
}
```

## 希尔排序

希尔排序是对插入排序的改进，它将数组分为多个子数组来进行排序。

希尔排序可以更快地将大的元素移动到正确的位置，交换操作会更少。

```js
function shellSort(arr) {
  // 步长
  let gap = Math.floor(arr.length / 2);

  while (gap > 0) {
    // 按照步长给元素分组
    for (let i = 0; i < gap; i++) {
      // 每组进行插入排序
      for (let j = i + gap; j < arr.length; j += gap) {
        for (let m = i; m < j; m += gap) {
          if (arr[j] < arr[m]) {
            const temp = arr[m];
            arr[m] = arr[j];
            arr[j] = temp;
          }
        }
      }
    }

    // 减少步长
    gap = Math.floor(gap / 2);
  }
}
```

## 归并排序

```js
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  const sortedLeft = mergeSort(left);
  const sortedRight = mergeSort(right);

  return merge(sortedLeft, sortedRight);
}

// 合并两个有序数组
function merge(left, right) {
  const merged = [];
  let leftIndex = 0;
  let rightIndex = 0;

  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      merged.push(left[leftIndex]);
      leftIndex++;
    } else {
      merged.push(right[rightIndex]);
      rightIndex++;
    }
  }

  while (leftIndex < left.length) {
    merged.push(left[leftIndex]);
    leftIndex++;
  }

  while (rightIndex < right.length) {
    merged.push(right[rightIndex]);
    rightIndex++;
  }

  return merged;
}
```

## 快速排序

```js
function quickSort(arr) {
  if (arr.length === 0 || arr.length === 1) return arr;
  let low = 0;
  let high = arr.length - 1;
  let pivot = arr[0];
  let moveHigh = true;
  while (low !== high) {
    if (moveHigh) {
      if (arr[high] >= pivot) {
        high--;
      } else {
        arr[low] = arr[high];
        low++;
        moveHigh = false;
      }
    } else {
      if (arr[low] <= pivot) {
        low++;
      } else {
        arr[high] = arr[low];
        high--;
        moveHigh = true;
      }
    }
  }
  arr[low] = pivot;

  return [
    ...quickSort(arr.slice(0, low)),
    pivot,
    ...quickSort(arr.slice(low + 1)),
  ];
}
```

## 堆排序

## 计数排序

通过计数而不是比较来排序

```js
function countingSort(arr) {
  if (arr.length < 2) return;

  // 找到最大值
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }

  const countingArr = Array(max + 1).fill(0);
  for (let i = 0; i < arr.length; i++) {
    countingArr[arr[i]] += 1;
  }

  let sortedIndex = 0;
  for (let i = 0; i < countingArr.length; i++) {
    while (countingArr[i] > 0) {
      arr[sortedIndex] = i;
      sortedIndex++;
      countingArr[i]--;
    }
  }
}
```

## 基数排序

```js
function radixSort(arr) {
  // 最大值
  const max = Math.max(...arr);
  // 最大值的位数
  const maxDigits = Math.floor(Math.log10(max) + 1);

  for (let i = 0; i < maxDigits; i++) {
    // 10个桶
    const buckets = Array.from({ length: 10 }, () => []);

    for (let j = 0; j < arr.length; j++) {
      const digit = Math.floor(arr[j] / Math.pow(10, i)) % 10;
      buckets[digit].push(arr[j]);
    }

    arr = buckets.flat();
  }
  return arr;
}
```

## 桶排序

```js
function bucketSort(arr, bucketSize = 3) {
  // 最大值和最小值
  let min = arr[0];
  let max = arr[0];
  for (let i = 0; i < arr.length; i++) {
    if (min > arr[i]) min = arr[i];
    if (max < arr[i]) max = arr[i];
  }

  // 桶的初始化
  const bucketCount = Math.floor((max - min) / bucketSize) + 1;
  const buckets = [];
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [];
  }

  // 分配到各个桶中
  for (let i = 0; i < arr.length; i++) {
    const index = Math.floor((arr[i] - min) / bucketSize);
    buckets[index].push(arr[i]);
  }

  // 对每个桶进行排序
  arr.length = 0;
  for (let i = 0; i < buckets.length; i++) {
    buckets[i].sort((a, b) => a - b);
    for (let j = 0; j < buckets[i].length; j++) {
      arr.push(buckets[i][j]);
    }
  }
}
```

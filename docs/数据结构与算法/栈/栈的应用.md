# 栈的应用

## 括号匹配

```js
const isBracketMatch = (str) => {
  const stack = new Stack();
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === '(') {
      stack.push(char);
    } else if (char === ')') {
      if (stack.isEmpty()) {
        return false;
      }
      stack.pop();
    }
  }
  return stack.isEmpty();
}
```

## 求斐波那契数

```js title=用递归实现
const fibonacci = (n) => {
  if (n <= 2) return 1;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

```js title=用栈实现
const fibonacci = (n) => {
  if (n <= 2) return 1;
  const stack = new Stack();
  stack.push(1);
  stack.push(1);
  let i = 2;
  while (i < n) {
    const first = stack.pop();
    const second = stack.pop();
    stack.push(first);
    stack.push(first + second);
    i++;
  }
  return stack.pop();
}
```

## 十进制转二进制

```js
const decimalToBinary = (decNumber) => {
  const stack = new Stack();
  while (decNumber > 0) {
    stack.push(decNumber % 2);
    decNumber = Math.floor(decNumber / 2);
  }
  let binaryString = '';
  while (!stack.isEmpty()) {
    binaryString += stack.pop();
  }
  return binaryString;
}
```

```js title=十进制转任意进制
const baseConverter = (decNumber, base) => {
  const stack = new Stack();
  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  while (decNumber > 0) {
    stack.push(decNumber % base);
    decNumber = Math.floor(decNumber / base);
  }
  let binaryString = '';
  while (!stack.isEmpty()) {
    binaryString += digits[stack.pop()];
  }
  return binaryString;
}
```

## 表达式求值

```js title=中缀表达式转后缀表达式
const priority = (peek) => {
  switch (peek) {
    case '+':
    case '-':
      return 1;
    case '*':
    case '/':
      return 2;
  }
}

const infixToPostfix = (str) => {
  const stack = new Stack();
  const operators = '+-*/()';
  const tokens = str.split('');
  let postfix = '';
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token === ' ') continue;
    if (operators.includes(token)) {
      if (token === '(') {
        stack.push(token);
      } else if (token === ')') {
        let top = stack.pop();
        while (top !== '(') {
          postfix += top + ' ';
          top = stack.pop();
        }
      } else {
        while (!stack.isEmpty() && priority(stack.peek()) >= priority(token)) {
          postfix += stack.pop() + ' ';
        }
        stack.push(token);
      }
    } else {
      postfix += token + ' ';
    }
  }
  while (!stack.isEmpty()) {
    postfix += stack.pop() + ' ';
  }
  return postfix;
}
```

```js title=后缀表达式求值
const calc = (str) => {
  const stack = new Stack();
  const operators = '+-*/';
  const tokens = str.split(' ');
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (operators.includes(token)) {
      const second = stack.pop();
      const first = stack.pop();
      switch (token) {
        case '+':
          stack.push(first + second);
          break;
        case '-':
          stack.push(first - second);
          break;
        case '*':
          stack.push(first * second);
          break;
        case '/':
          stack.push(first / second);
          break;
      }
    } else {
      stack.push(Number(token));
    }
  }
  return stack.pop();
}
```
## 什么是对象

语言即思维模式。

编程语言是用于创建应用程序的思维模式。面向对象编程(Object-Oriented Programming, OOP)是把计算机作为表达媒介的一种表达方式。

抽象的历程

问题空间与解决方案空间



构建机器模型。程序员必须在机器模型和问题模型之间建立关联。



构建问题模型。面向对象编程为程序员提供了一些能够呈现问题空间元素的工具。问题空间中的元素及其解决方案空间中的具体呈现，我们称其为“对象”。

对象具有接口

所有的对象，哪怕是相当独特的对象，都能被归为某一类，并且同一类对象拥有一些共同的行为和特征。



“同一类对象(class of objects)”就是关键字class的由来。



因为类描述了一系列具有相同特征和行为的对象，所以类其实就是数据类型。

对象可以提供服务

隐藏

只暴露必要的接口

访问修饰符

复用

组合

利用已有的类组合成一个新的类，叫做组合，代表一种有(has-a)的关系。



聚合

如果组合是动态的，叫做聚合。

继承

is-a

is-like-a

多态

单根层次结构

集合

对象的创建和生命周期

异常处理

## 安装Java

## 对象无处不在

通过引用操作对象

引用的作用是关联对象。

必须创建所有对象

除了基本类型。

注释

无需销毁对象

使用class关键字创建新类型

基本类型的字段会有默认值，局部变量如果没有初始化会报错。

方法、参数以及返回值

方法名和参数列表共同构成了方法的签名，方法签名即该方法的唯一标识。

编写Java程序

你的第一个Java程序

所有的Java代码文件都默认导入了java.lang

程序入口main()

必须是public。

必须是static。

必须是void。

必须要有入参。

编程风格

## 操作符

操作符用来操作数据。



几乎所有的操作符都只能操作基本类型，例外的是

=、== 和!=也能操作对象

String类也支持+、+=

赋值操作符

左值必须是一个独特的命名变量（也就是说，必须有一个物理空间来存储右值）。

算数操作符

+、-、*、/、%

一元加操作符、一元减操作符

唯一的作用就是将较小类型的操作数提升为int类型

自增、自减

除了涉及赋值的操作符，它们是唯一具有副作用的操作符。

关系操作符

<、>、<=、>=、==、!=

逻辑操作符

&&、||、!

字面量

字面量的后缀字符标识了它的类型

l、L long类型

f、F float类型

d、D double类型



0b、0B 二进制

0 八进制

0x、0X 十六进制



可以在数字字面量里使用下划线

数字开头和结尾不能使用

L、F、D、B、X周围不能有下划线



科学计数法（又称指数计数法）

按位操作符

&、|、^、~

移位操作符

<<、>>、>>>

三元操作符

也叫条件操作符

字符串操作符

+、+=

类型转换操作符

boolean 不允许进行任何类型的转换处理，其他基本类型都可以相互强制转换。

浮点型转整型，会把小数截掉。

对小于int类型的基本类型（即char、byte、short）执行算术运算或按位运算，运算执行前这些值会被自动提升为int，结果也是int。

## 控制流

if-else

if (Boolean-expression)
statement
else
statement


else if并非新的关键字，只不过是一个else后面紧跟一个新的if语句。

迭代语句

while

do-while

for

逗号操作符不是逗号分隔符，逗号分隔符用来分割声明和函数的不同参数，而Java里唯一用到逗号操作符的地方就是for循环的控制表达式。

for-in

用于Iterable对象。

return

void方法中如果没有return语句，那么方法的结尾处会有一个隐含的return。

break、continue

在Java中，使用标签的唯一理由就是想跳出嵌套循环。

switch

switch (selector) {

}

switch选择器只能是整数值或字符串。



## 初始化和清理

初始化和清理正是导致“不安全”编程的两个因素。

用构造器保证初始化

构造器的名字就是类的名字。

方法重载

每个重载方法必须有独一无二的参数类型列表。

无参构造器

如果已经定义了一个构造器，无论是否有参数，编译器都不会再帮你创建一个无参构造器了。

this关键字

当前方法里的this引用会自动应用于同一类中的其他方法。



可以通过this调用另一个构造器，但

不能同时调用两个

必须出现在方法的最开始部分



编译器禁止在非构造器的普通方法里调用构造器。

清理：终结和垃圾收集

成员初始化

类的字段会被自动初始化。

成员变量不初始化会报错。

构造器初始化

初始化顺序

静态初始化，只在Class对象首次加载时发生一次

字段初始化，实例初始化

执行构造器

数组初始化

数组是一个对象序列或基本类型序列。



这种初始化只能在定义时使用

int[] arr = {1, 2, 3};

这种初始化任何时候都可以使用

int[] arr = new int[]{1, 2, 3};

指定长度不初始化，元素有默认值

int[] arr = new int[3];

枚举类型

枚举类型的实例是常量。

局部类型推断

普通方法和静态方法中的局部变量允许类型推断。



## 实现隐藏

package：库单元

一个包包含了一组类，这些类通过同一个命名空间组织在了一起。



package语句必须是第一行非注释代码。



当创建一个包并给其命名时，你就隐式的指定了目录结构。这个包必须位于其名称指定的目录中，并且该目录必须可以从CALSSPATH搜索到。

访问权限修饰符

修饰字段和方法。

public

包外可见。

protected

继承访问权限

包访问权限

包内可见。

private

本类可见。

接口和实现

访问控制常常被称为实现隐藏。将数据和方法包装在类中，并于实现隐藏相结合，成为封装。

类的访问权限

访问权限修饰符还决定了库内部的哪些类可以提供给用户使用。

类只能是public或包访问权限，对于包访问权限类的成员设为public或protected没什么用。

模块

导入导出包。

## 复用

组合语法

继承语法

当创建子类对象时，它里面包含了一个基类的子对象。这个子对象与直接通过基类创建的对象一样。只是从外面看，基类的子对象被包裹在了子类的对象中。

如果子类声明了构造器，则必须在其中显示的调用父类构造器。

委托

组合与继承相结合



选择组合还是继承

组合表示has-a的关系，继承表示is-a的关系。

确定是使用组合还是继承的最清晰的方法之一，就是询问是否需要从新类型向上转型到基类。

protected关键字

继承的子类也可访问protected成员。

向上转型

final关键字

final数据

final基本类型，则是编译时常量。final引用类型，则引用不可变更，但对象本身可以修改。

final字段的初始化，要么在定义时，要么在构造器。



final方法

不允许重写。

private方法隐含是final的。



final类

不允许继承。

初始化及类的加载

类的代码在第一次使用时才加载。访问静态成员也会触发。尽管没有显示指定static关键字，但构造器也是一个静态方法。



## 多态

再论向上转型

获取对象引用并将其当做基类型的引用成为向上转型。



忘记子类型的存在，只编写与基类打交道的代码，这样不是很好吗？这正式多态所能够实现的。

难点

方法调用绑定

后期绑定



产生正确的行为

后期绑定（多态）



可扩展性

多态是程序员“将变化的事物与不变的事物分离”的一项重要技术。



陷阱：重写private方法

private方法自动就是final的，并且对子类也是隐藏的。



陷阱：字段与静态方法

只有普通的方法调用可以是多态的。

构造器和多态

构造器是隐式static的，构造器不是多态的。

协变返回类型

子类方法中重写方法的返回值可以是基类方法返回值类型的子类型。

用继承进行设计

使用继承来表达行为上的差异，使用字段来表达状态上的变化。



向上转型会丢失特定类型的信息，通过向下转型可以重新获取类型信息。Java会在运行时强制转型，如果不是期望的类型，则会报ClassCastException错误。这种在运行时检查类型的行为是Java反射的一部分。



## 接口

接口和抽象类提供了一种更加结构化的方式来分离接口与实现。

抽象类和抽象方法

抽象类的成员的访问权限和普通类的成员一样。

接口定义

接口里的方法默认是public的，也只允许public。

接口里的方法默认是abstract的。



接口可以包含静态字段，隐式static和final。



默认方法

default

默认实现

实现的多个接口中不能有签名相同的默认方法，可以通过重写解决。



静态方法

抽象类与接口

在合理的范围内尽可能抽象。

完全解耦

组合多个接口

通过继承来扩展接口

接口可以extends接口，且可以extends多个。



函数名相同时

如果参数列表不同，则表示重载

如果参数列表相同，返回类型也相同，则表示重写

如果参数列表相同，返回类型不相同，则冲突

适配接口

接口中的字段

接口中的任何字段都是自动static和final的。

可以用非常量表达式初始化。

嵌套接口

接口和工厂

接口的private方法

private自动default。

密封类和密封接口

限制自己能派生哪些类。



sealed类的子类需要用final、sealed、non-sealed三者之一修饰。



record是隐式final。



密封层次结构不允许向下转型。

## 内部类

定义在另一个类中的类成为内部类。

创建内部类

创建内部类的方式就是把类定义在一个包围它的类之中。

到外部类的链接

内部类拥有对外部类对象所有元素的访问权。

使用.this和.new

如果内部类是嵌套类（static修饰），则可以直接创建内部类对象。否则，只能通过外部类对象创建。

外部类对象.new 内部类()

内部类引用外部类对象

外部类.this

内部类和向上转型

在方法和作用域中的内部类

叫做局部内部类。任何作用域内都可以定义类。

匿名内部类

匿名内部类不可能有构造器。

嵌套类

static的内部类

为什么需要内部类

内部类是面向对象的闭包。

继承内部类

内部类可以被重写吗

不能。可以显示的继承。

局部内部类

局部内部类不能使用权限修饰符。

匿名内部类不能有具名的构造器，只有一个实力初始化部分。

内部类标识符

外围类的名字+$+内部类的名字。

如果是匿名内部类，编译器会以数字作为内部类标识符。



## 集合

集合类也叫做容器类。

不能在集合类中使用原始类型。

泛型和类型安全的集合

基本概念

添加一组元素

打印集合

List

有序

ArrayList

LinkedList

Iterator

Stack

Set

不重复。

Set（除了TreeSet）与Collection具有相同的接口，只是行为不同。

HashSet

TreeSet

LinkedHashSet

Map

Map使用另一个对象来茶轴某个对象，它也被称作关联数组，或者字典。

HashMap

TreeMap

LinkedHashMap

记录（record）类型

record定义的是希望成为数据传输对象的类，编译器会自动生成

不可变的字段：private final

一个规范的构造器：构造器会根据其参数来初始化这些字段，不能向record中添加字段，只能将其定义在头部

每个元素都有的访问器方法：每个属性会自动获得自己的访问器

equals()：自动创建合理的hashCode()和equals()

hashCode()

toString()

可以加入静态的方法、字段、初始化器。

record是自动final的，且不能为abstract。

record也不能继承其他类，但可以实现接口。

可以定义方法，但这些方法是自动final的。



紧凑构造器

可以修改字段的初始值



普通构造器

也可以使用普通构造器，但必须原样复制record的签名



嵌套和局部record都是隐含静态的。

Queue

PriorityQueue

Collection和Iterator的对比

for-in和迭代器

所有的Collection（不包括Map）都可以使用for-in遍历。



数组可以配合for-in使用，但并没有实现Iterable接口。



## 函数式编程

面向对象编程抽象数据，而函数式编程抽象行为。

旧方式与新方式

lambda表达式

方法引用

lambda表达式

lambda表达式是单一函数接口的实现。



函数体没有括号时，不能写return。

方法引用

方法引用是用类名或对象名，后跟::，然后跟方法名。



未绑定方法引用

注意隐藏的参数this

函数式接口

函数式接口，也叫单一抽象方法类型

@FunctionalInterface

函数式方法是lambda表达式和方法引用的目标类型。

高阶函数

高阶函数只是一个能接受函数作为参数或能把函数当返回值的函数。

闭包

只要有内部类，就会有闭包。

函数组合

柯里化和部分求值

柯里化的意思是，将一个接受多个参数的函数转变为一系列只接受一个参数的函数。

纯函数式编程

## 流

流与对象的成批处理有关。

Java8对流的支持

流的创建

中间操作

Optional操作

终结操作

## 异常

概念

基本的异常

捕捉异常

创建自己的异常

异常说明

捕捉任何异常

标准Java异常

更好的NullPointerException

使用finally执行清理

异常的约束

构造器

try-with-resources语句

异常匹配

其他可选方式

异常使用指南

## 代码校验

测试

单元测试

JUnit

测试覆盖率

前置条件

断言

Java断言assert

Guava里的断言

测试驱动开发

日志

调试

基准测试

分析与优化

样式检查

静态错误分析

代码审查

结对编程

重构

在开始重构代码之前，必须具备一下三个支持系统

测试。通常来说，最低要求是要有JUnit测试。

构建自动化。更容易构建代码并运行所有测试。

版本控制。随时回退到可工作的版本。

没有这三个系统，重构几乎是不可能的。

持续集成

## 文件

文件和目录路径

Path对象代表的是一个文件或目录的路径，它是在不同的操作系统和文件系统之上的抽象。

目录

文件系统

监听Path

查找文件

读写文件

## 字符串

不可变的字符串

重载+与StringBuilder

应用于String的+和+=是Java中仅有的被重载的操作符，Java不允许程序员重载其他操作符。

无意识的递归

对字符串的操作

格式化输出

文本块

正则表达式

扫描输入

StringTokenizer

## 反射

反射的意思：在运行时，确定对象的类型。

为什么需要反射

Class对象

转型前检查

注册工厂

Instanceof与Class的等价性

运行时的类信息

动态代理

使用Optional

接口和类型信息

## 泛型

“泛型”的意思是“适用或者可兼容大批的类”。

和C++的对比

简单泛型

泛型接口

泛型方法

构建复杂模型

类型擦除的奥秘

对类型擦除的补偿

边界

通配符

问题

自限定类型

动态类型安全

异常

混乱

潜在类机制

对于缺少（直接的）潜在类型机制的补偿

Java8中的辅助潜在类型机制

## 数组

数组可以保存基本类型，Collection只能依靠自动装箱变相的保存。

## 枚举类型

枚举类型的基本特征

枚举类型自动继承`java.lang.Enum`，不允许显示继承

枚举类型不允许被继承

枚举类型可以实现接口

静态导入枚举实例

定义在同一个文件中或者定义在默认包中的枚举类型，无法通过`import static`静态导入其枚举实例，只能使用枚举类型来限定枚举实例。

在枚举类型中增加自定义方法

实例必须在自定义方法之前

构造器的访问权限必须是包级或private

在switch语句中使用枚举

values()方法的神秘之处



随机选择

使用接口来组织枚举

用EnumSet来代替标识

使用EnumMap

常量特定方法

多路分发

支持模式匹配的新特性

switch中的箭头语法

switch中的case null

将switch作为表达式

智能转型

模式匹配

## 对象传递和返回

传递引用

创建本地副本

控制可克隆性

不可变类

## 注解

基本语法

编写注解处理器

用javac处理注解

基于注解的单元测试

## 并发编程

令人迷惑的术语

并发的超能力

并发为速度而生

Java并发四定律

残酷的事实

并行流

创建和运行任务

终止长时间运行的任务

CompletableFuture

死锁

一个互相等待的无限循环。

构造器并不是线程安全的

工作量、复杂性、成本

## 底层并发

什么是线程

捕获异常

共享资源

volatile关键字

原子性

临界区

库组件

## Java I/O系统
I/O流

标准I/O

新I/O


